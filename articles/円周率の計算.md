# 円周率の計算

円周率を非常に長い桁計算することは数学的・工学的にはあまり意味がないそうです。しかし2024年6月に202兆桁超の計算をしたという記録が残っています。人間はこの円周率の無理性になぜか惹かれてしまうのでしょう。または計算アルゴリズムやソフトウェアを最適化する技術を培うための練習なのかもしれません。まあ自分もそのロマンに少し惹かれてしまったのでちょっとやってみるかという記事です。SF当日までに今作っている円周率分散計算プラットフォームが完成していたら、ご参加いただけると嬉しいです。参加されたい方はお声がけください。

この記事では円周率を計算する数学的な方法から始まり、現代的な円周率計算アルゴリズムをコンピュータ上でどうやって高速に動作させるかについての技術について紹介していきます。ちなみに、これらの技術は実際にほとんどが円周率分散計算プラットフォームに利用されています。

厳密な詳細は、自分が参考にした以下の京大の資料を直接みるのが良いと思います。この記事はあくまでも楽しむ目的の読者を想定しています。

https://www.kurims.kyoto-u.ac.jp/~ooura/pi04.pdf

## 数学的背景

#### 多角形近似
円周率の計算を行う方法はたくさんあります。一番有名かつ基本的なものが多角形近似です。
円の内接正n角形と外接正n角形を用いて行うものです。以下のような感じですね。

[](../assets/pi-01.jpeg)

図より、
$$ n \sin{\frac{\pi}{n}} <  \pi < n \tan{\frac{\pi}{n}}$$

例えば、$n=6$なら
$$ 3 < \pi < \frac{6}{\sqrt{3}} \fallingdotseq 3.46$$

#### 級数の利用

次は級数を使うとはどういうことかについて説明します。例として*tan*の性質を用いる方法を紹介します。

まずは*tan*の逆関数*arctan*を導入します。$\tan{x}$は定義域$-\frac{\pi}{2}<x<\frac{\pi}{2}$において、値域$-\infty<\tan{x}<\infty$を取りますから、$-\frac{\pi}{2}<x<\frac{\pi}{2}$の範囲が問答無用で返されるようにすれば任意実数について$\arctan$を定義できます。

初項1、公比-x^2の等比数列を考えて、

$$
\frac{1}{1+x^2}=1-x^2+x^4-x^6+x^8-・・・
$$

両辺0からxで積分して

$$
\arctan{x}=x-\frac{1}{3}x^3+\frac{1}{5}x^5-\frac{1}{7}x^7+\frac{1}{9}x^9-・・・
$$

xに適当に1を放り込むと...

$$
\frac{\pi}{4}=1-\frac{1}{3}+\frac{1}{5}-\frac{1}{7}+\frac{1}{9}-・・・
$$
というふうに円周率の近似公式を得られました。
ちなみに、10項まで計算すると、3.0418...となります。収束は結構遅い感じでしょうか。ライプニッツの公式と呼ばれます。積分を使って$\arctan$を半ば無理やり捻り出すのがよく思いついたなという感じで面白いですね。

#### Chudnovsky級数を利用した方法

時間がないということでいきなり最先端の計算法に飛びます。
以下のような公式が「なぜか」成り立ちます。

$$\frac{1}{\pi} = 12 \sum_{k=0}^{\infty} \frac{(-1)^k (6k)!}{(3k)! (k!)^3} \cdot \frac{13591409 + 545140134k}{640320^{3k + 3/2}}$$

笑ってしまうほどよくわからない等式ですが、とにかく成り立つらしいです。証明や概念的な説明を理解しようとしたのですが、無理でした。「π が登場する超幾何級数の一般論に、π と j 不変量を結びつけるモジュラー形式の強力な理論を適用し、さらに j(τ) が非常に単純な代数的数となるような魔法のような  τ を選ぶことで、π に収束することが示される」だそうです。人生の目標に、これの証明を理解するという目標を加えました。

> 発見者はラマヌジャンかなと思われた方が多いと思いますが惜しいです。これはラマヌジャンの公式を改良したものだそうです。

こんな公式をなぜ使うかというと、1項計算するごとに14桁が求まるという脅威的な収束スピードを持っているからです。例えば、先ほどの*tan*の方法だと10項計算して一桁しか求まっていませんが、こいつは10項も計算したら140桁も求まっているわけです。

## 技術の話

「あれこの記事終わるの早いな」と思われた方多いと思いますが、実は自分からすると本題はこれからです。

「これをどうやってコンピュータで計算するんだ？」ということです。そもそも答えが100万桁の少数になります。最近のコンピュータに入っているCPUの浮動小数点計算ユニットで標準的に直接サポートされるのは10進数で言うと有効数字17桁が最大です。なぜ100万桁の演算をサポートしていないかというと、そんな機能は絶対にいらないからです。

例えば100万桁の円周率を計算するには100万桁(+数桁)の有効数字を持つ小数点を操る必要があります。そこで100万桁を34桁×29412回の計算に分割して行います。

またコンピュータ上での小数点の表現の仕方である浮動小数点はイメージ$1.011100010101\times 2^{100101}$というような形をして保存されています。小数点がまるで浮いているように自由に動き回るというイメージです。なので毎回の計算に指数部の計算をしなければいけませんし、その分メモリが無駄になりますから「量子化」という技術で少数演算を整数演算に変換します。

たいそうな名前がついていますがそんなに難しくありません。例えば100万桁の円周率計算をするのであれば、最初から100万をかけて整数として扱っても問題ないはずです。これが量子化です。量子力学は電子のエネルギーが飛び飛びの値をとるということから始まった理論ですが、そもそも量子というのは離散的という意味なんです。余談ですが、AI分野の方でも量子化が使われていたりします。

#### 計算量とは？

そろそろ、計算量という概念について説明しておきます。計算量とは数学的に処理にどのぐらい時間がかかるかを調べる指標の一つです。
「このアルゴリズムは$O(n)$」のように使います。「このアルゴリズムは規模に比例して計算量が大きくなっていく」という意味です。
処理速度を関数の発散速度としてみます。発散が速いことで有名な指数関数の速さのアルゴリズムなら遅い。発散が遅いことで有名な対数関数の速さのアルゴリズムなら速いといった感じです。

大抵コンピュータでやるような計算は、この発散速度が優位に現れてくるような規模で行いますから、係数なんかよりも発散速度の方が重要になってくるということです。

例えば、$10000000000\log(n)$と$e^n$のアルゴリズムを比較する時、見た目では前者の方が遅いように見えます。しかし実際に代入してみると以下のように小さな$x$ではもちろん前者が遅いですが、大きな$x$では圧倒的な差で前者の方が速いです。
$$
x=2→3010299957・7.38
$$
$$
x=100→20000000000・2.7\times10^{43}
$$
よって高速な演算を目指す場合はできるだけ発散が遅いようなアルゴリズムを選定するのが大事だということです。

#### チェドノフスキーの使い方

結論から言うと、最新の円周率計算アルゴリズムの計算量は、$O(n\log^3{n}\log{\log{n}})$となります。

鋭い方はおかしいと思ったかもしれません。なぜなら掛け算に$O(n^2)$かかるからです。

伝統的に小学校で習う掛け算の筆算を使った計算では、n桁同士の乗算をするには筆算の下に書いた数字それぞれについて上の数字と掛け算をします。つまり九九表を$n^2$回見ると計算が終わります。詰まるところ計算量は$O(n^2)$です。そこんところすごい工夫があるわけですね。

#### FFTを使った高速乗算

FFTとは高速フーリエ変換のことです。

フーリエ級数の話をすると10個ぐらい記事ができてしまいますし、最近勉強したことできちんと説明できる自信があまりないので飛ばしてイメージのみ説明します。

まずは整数の乗算と多項式の乗算が本質的に同じであることを説明します。

例えば、
$$
(ax^2 + bx + c)(px^2 + qx + r)\\
=apx^4 + (aq + bp)x^3 + (ar + cp + bp)x^2 + (br + cq)x + cr
$$
は、「abc」と「pqr」という十進数の掛け算と同じです。この演算は**畳み込み**と呼ばれます。

畳み込みは連続の世界で関数同士でも定義できて、以下のような式が成り立ちます。
2つの関数の畳み込みを$*$で表すと、
$$ \mathcal{F}\{ (f * g)(t) \} = F(\omega) G(\omega) $$
です。詳細な説明は省きますが、この美しい性質が離散の世界でも成り立ちます。直感的には以下の通りです。
$$
(ax^2 + bx + c)(px^2 + qx + r)\\
=apx^4 + (aq + bp)x^3 + (ar + cp + bp)x^2 + (br + cq)x + cr
$$
の$x$に具体的な値を（未知数が5個なので代数学の基本定理より5連方程式が必要）5個代入して、できた線形連立方程式を解いて多項式の乗算結果を計算します。これはさっきの説明からもちろん整数の乗算にお
いても使えます。

この5個には、何乗かしたら元に戻るようなものを代入したらうまいこと連立方程式の未知数が消去できます。「何乗かしたら元に戻ると言えば複素数！」と言
うわけでなんと複素数を代入します。

例えばこの場合なら$x=1, e^{\frac{2}{5}\pi i},e^{\frac{4}{5}\pi i},e^{\frac{6}{5}\pi i},e^{\frac{8}{5}\pi i}$を代入するとうまくいきます。

#### NTTを使った高速乗算
FTTの変化形です。FTTではうまいこと消えるものとして複素数を選びましたが、これでは複素数計算の際に小数点を使う必要があり、コンピュータでやるのは少し遅いですし、誤差が発生します。そこで複素数ではなく合同式において複素数のような性質を持つ整数を使います。
合同式の世界で見た整数はよくみると複素数に似ています。

例えば、法を5とする世界において2でかけることは複素数でいう回転の操作にあたります。
```
1 -> 2 -> 4 -> 3 -> 1
```
0を除かないといけないので、n個の数字を考えるとしたらn+1を法として考えます。すると何らかの数字が回転するための「素子」となると言った感じです。

この性質を利用すると、あの特殊な形の線形代数をいい感じに消去して効率的に計算することができるというわけです。

計算量は$O(n \log n)$となります。

#### バイナリスプリッティング
バイナリスプリッティングは、デカい数でできた分数和を効率的に計算するアルゴリズムです。

まず、チェドノフスキーの公式は以下。（再喝）

$$\frac{1}{\pi} = 12 \sum_{k=0}^{\infty} \frac{(-1)^k (6k)! (A + Bk)}{(3k)! (k!)^3 C^{3k + 3/2}}$$

ここで、$A, B, C$  は以下の定数です。

-   $A = 13591409$
-   $B = 545140134$
-   $C = 640320$

当たり前ですが無限和は計算できないので、級数を  $N$  項までの有限和で近似します。

$$\frac{1}{\pi} \approx 12 \sum_{k=0}^{N-1} \frac{(-1)^k (6k)! (A + Bk)}{(3k)! (k!)^3 C^{3k + 3/2}}$$

この級数の一般項を  $T_k^{full}$  と定義します。

$$T_k^{full} = \frac{(-1)^k (6k)! (A + Bk)}{(3k)! (k!)^3 C^{3k + 3/2}}$$


以下のような再帰関数 `Compute(a, b)` を定義し、`P_prod`, `Q_prod`, `S_num` の3つの値を返すことにします。

*   `P_prod(a, b)`: 再帰区間$[a,b)$における分子側の因子の積。
*   `Q_prod(a, b)`: 再帰区間$[a,b)$における分母側の因子の積。
*   `S_num(a, b)`: 区間$[a,b)$における和の分子部分。

これらの値は、中間点  $m = \lfloor \frac{a+b}{2} \rfloor$  を用いて、

$$
\begin{aligned}
P(a, b) &= P(a, m) \cdot P(m, b) \\
Q(a, b) &= Q(a, m) \cdot Q(m, b) \\
T(a, b) &= T(a, m) \cdot Q(m, b) + P(a, m) \cdot T(m, b)
\end{aligned}
$$

ここで、$P(a,b)$, $Q(a,b)$, $T(a,b)$ は上記で定義した `P_prod(a,b)`, `Q_prod(a,b)`, `S_num(a,b)` に対応します。

区間の最小単位（$b = a+1$）における基底ケースは、直接計算する必要があります。

$k \ge 0$ に対し、以下のように定義します：
-   $P(k, k+1) \rightarrow p_k = - (6k+1)(6k+2)(6k+3)(6k+4)(6k+5)(6k+6)$
-   $Q(k, k+1) \rightarrow q_k = (3k+1)(3k+2)(3k+3)(k+1)^3 C^3$
-   $T(k, k+1) \rightarrow s_k = A + B(k+1)$

最終的に、`Compute(0, N)`を呼び出して得られた $T(0, N)$ と $Q(0, N)$ を用いて $\pi$ の近似値を計算します。

$$\frac{C^{3/2}}{12} \cdot \frac{1}{\pi} \approx \frac{T(0, N)}{Q(0, N)}$$
