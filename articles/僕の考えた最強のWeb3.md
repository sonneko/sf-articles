# 僕の考えた最強のWeb3

まず現在のインターネットの世界というのは、Web2といわれます。Web3とはその次の世代のもののことです。

- Web1: 情報が一方的にサーバーからクライアントに流れていく
- Web2: サーバーを経由してクライアント同士がインタラクトする（中央集権的）
- Web3: 直接クライアント同士がインタラクトする（分散型）

現在のシステムというのは大抵サーバーがメインとなってクライアントを操るという構成になっています。しかしそれではサーバーにその分負荷がかかりますしエッジデバイスの計算資源を有効活用することが難しいです。またサーバーが何らかの不具合で止まった時に全てのシステムが止まってしまいます。そこで主体をクライアントに分散させることで安定・次世代的なインターネットを作ろうというのがWeb3の思想です。

「僕の考えた最強のWeb3」というのは、互換性を重視したネットワーク構想です。
僕はブラウザで動くかどうかがアプリケーションの大きな違いの一つだと考えていますから、このネットワークはブラウザで動くように設計しました。ブラウザでは基本的にHTTP通信しか使うことができないのですが、一つ抜け道がありそれがWebRTCです。

WebRTCとは`Web Real Time Communication`の略でP2P通信というデバイス同士を直接接続するプロトコルの上に構築されたプロトコルです。例えばZoomなどに使われています。

ブラウザ→HTTP→サーバー
ブラウザ→WebRTC→ブラウザ

>P2Pはシグナリングという操作を行わないと通信を始めることができません。シグナリングは基本的にはHTTPを用いてサーバーを使って行われますが、デバイス同士の情報を交換すればいいだけなので具体的な方法は規定されていません。

そこでP2PでWeb3を作ろうとしたわけです。しかし一つ大問題が発生します。P2Pを使ってネットワークを作ろうとすると、どうしてもつなげたいサーバー全てに対してシグナリングをして通信を確立しないといけません。しかし大抵のデバイスはP2Pでの同時接続数が技術的な問題で制限されていて大抵数十個単位です。つまりこの方法だと同時に数十個のサーバーにしか通信をできないというわけです。

そこで現行のWebを真似てある工夫をしてみます。何らかのサーバーと接続する際に、直接サーバーと繋ぐのではなく近くのデバイスと接続して伝言ゲームをしていくことでサーバーと接続しようという工夫をします。そうすると同時接続しないといけない数を減らしつつたくさんのサーバーにアクセスできるようになります。

## プロトコルについて
まず、基盤の層から話していくと、Web3は革新的なものでありまだまだ実用化には程遠いと言うイメージが(自分にも)あります。なので、自分はできるだけ表層のアプリケーションのみを変更してある意味手軽なWeb3を作りたいと考えています。

そのためにWebRTCという技術を使います。これはブラウザから使えるP2PをするためのAPIで、本来はZoomなどのWeb会議に使われるAPIです。このAPIには、dataChennelというUDPに信頼性を持たせたチャンネルがあり、それを利用して低レイヤーをできるだけ触らずにWeb3を実現します。

イメージは、WebRTCの上にOSI参照モデルでいうIPより上の階層をもう一度積み上げるようなものです。
```
WebRTC -> DataChannel -> RoutingLayer -> TrasnportLayer -> ApplicationLayer
```
このアプローチをWebTCPと名づけました。またWeb3の目玉の一つである分散アプリケーション・分散ストレージ・ブロックチェーンなども基盤として提供することで、分散アプリケーションの開発を簡易にし、Web3の普及を図ります。

ここまでのWeb3のアイデアをWebRTCの上に積み上げようとしている人は、ネットで自分が調べた限りいませんでした。

こんなことを考えていくうちに、これはWebRTCでなくても任意の同様なプロトコル上で積み上げることができると思うので、チェンネルを`IRTCChennel`として抽象化しブラウザだけでなくクライアントのネイティブアプリ・サーバーでも動くようにしました。

ただし、WebRTC以外の同じような制限されたプロトコル上ではそれ同士の互換性が直接ありませんし、ブラウザ外でわざわざWebRTCをエミュレートするのも大変です。

そこでネットワーク自体をいろんな基盤プロトコル上に存在できるものとして抽象化し、それらの複数種類のネットワークの繋げ役（Web2でいうプロキシサーバーのようなもの）を`Adapter`という自由度の高いサーバーが担うアプリケーションとしてさらに抽象化します。

そうすると、Web2のネットワークとWeb3のネットワークを互換性を持って接続することが可能となります。

例えば、`webtcp://[...].[network_name].global`の形でWeb2におけるドメインに接続するように`global`トップレベルドメインとしてアクセスできるようにしてみます。ブラウザなど制限された環境ではWebRTCで`WebTCP2Web2Adapter`と通信をし、制限がない場合は直接アクセスするようにします。

`global`トップレベルドメインを定義することは他にも利点があって、例えばドメイン解決のためのネームサーバーを分散アプリケーション・ブロックチェーンとして管理することができます。例えば`domain.global`ドメインで統一的にドメイン取得ができたら嬉しいですよね。Web3を使うと、アプリケーションを実行する物理デバイスが分散することで、むしろ抽象化されたアプリケーションは集中しても問題なくなるというわけです。

またこの仕組みだと、現時点では特別なソフトウェアが必要なTor技術を理想したダークウェブも良くも悪くも簡単に実装できます。

## Webの技術
Web2で使われていたのは主にHTTP(S)通信でこれは`Hyper Text Transport Protocol(Secure)`の略です。ここでの`Hyper Text`とはHTMLなどの文書形式のことで、枯れた技術ですがあくまでも情報提供のためのプロトコルであり色々な意味での限界があります。

> ここでは簡略化のためWebというプラットフォームの問題をHTTP(S)になすりつけています。有識者の方は適宜HTTP(S)を`Web標準`に置き換えてください。HTTP(S)というのはあくまでもTCPの上に載った薄いラッパーです。

> 「枯れた」というのは長年使われてきたおかげで信頼性がありよく出回っているという良い意味です。Webはもちろん現在も活発で更新され続けていますが「枯れた」ということもできるだろうというのが僕の意見です。
 
大きな問題点の一つにXMLの重さ・ブラウザで動くプログラミング言語であるJavaScriptの根本的な速度限界・ブラウザの開発複雑化などがあると思います。それの解決の一つに僕は、WASIとP2P通信(もしくは同種の次世代プロトコル)の組み合わせを推しています。

まずは現状を理解するところから始めましょう。現状のWebは僕からするとすでに後方互換性のせいで良くも悪くも「継ぎ接ぎ状態」です。

Webは、Html(とcss)とJavaScriptで構成されます。Htmlは実はXMLを継承している言語で、XMLというのは昔使われていたデータトランスポーターです。今はほとんどJSONになっていますね。JSONはXMLに比べて軽量でパースしやすいという性質がありこれが代替となった理由です。

> データトランスポーター(独自定義)：データを通信しあうためのファイル形式のこと

> パース：ファイルを読み込み機械が扱えるような状態に変換すること

> XML：`<data name="名前？">ほにゃらら</data>`のような形式のこと

> JSON：`{ data: {name: "名前？", children: "ほにゃらら"}}`のような形式のこと。

> ちなみにGoogle開発の*Protocol Buffers*というより挑戦的な技術があります。これはテキストではなくバイナリで保存することでパース処理をなくして高速化しようという何方かと言えば組み込み開発的なアプローチのデータトランスポータで、スキーマがないと動かない代わりにその分最適化してくれます。現代は静的型がトレンドなのでスキーマ必須でもみんな使いそう...
> 詳しくは公式ドキュメント(英語)をどうぞ：https://protobuf.dev

> バイナリ：0と1で表す形式のこと。テキスト形式よりも効率的・軽量な傾向がある。機械が直接理解できる。

> スキーマ：データの構造を事前に示しておく時に使われる。英文における英文法のような存在。スキーマ必須の場合、ある程度の不自然さができるがその分セキュリティカル。最近トレンド。

> 型：データをどのような形でメモリに格納するかの形式のこと。「静的型」の場合、柔軟性低く・速く・安全で、「動的型」の場合、柔軟性高く・遅く・危険な傾向がある。「静的型」がトレンド。

JSONを継承したマークアップを作るのもいいと思いますが、マークアップとして使うなら最適かつ互換性もありAIとの相性もいいMD(MarkDown)という形式があります。

> マークアップ：ドキュメントを構成するためのファイル形式全般のこと

それはさておき、僕は宣言的なマークアップ言語なんていらないと考えていて、手続き的なUI構成WASIを宣言的マークアップ言語からビルド時生成すればいいのです。

>UI：ユーザーインターフェースの略。ここではデバイスで見るグラフィカルなインターフェースを指す。

>WASI: ブラウザで動くポータブルなバイナリ形式で保存できるプログラムである*WASM*(*WebAssembly*の略)が外部インターフェースを規格化した結果、ブラウザから飛び出し*WASM Runtime*という種のソフトウェア上で動くプログラムおよびその規格のこと。

> ポータブル：この場合、あらゆる環境(パソコン・スマホ)などで動くという意。

>外部インターフェース：OS・アーキテクチャ依存の部分の意。

>アーキテクチャ：平たくいうとCPUの種類のこと。(本当はソフトウェアレベルで定義されているCPUの種類のこと。)

>手続き的・宣言的：僕の書いた別の記事「日常へIT設計という概念を持ち込んでみる」を参照。

>ビルド時生成する：開発側のコンピュータで変換し変換結果をデバイスに配信するというアプローチのこと。

またJavaScriptというものは必要ありません。TypeScriptなどのように開発時に型が必要というのは痛いほどわかりますが、ビルド時に型情報を消してしまうのは明らかに非効率的です。時代の流れで消えてしまったasm.jsというもの方がよっぽど良かったような気がします。

>TypeScriptとはJavaScriptの欠点の一つである型がないということを解消するために型情報を書けるようにMicrosoftが開発したJavaScriptの派生言語。ただブラウザ互換性のためTypeScriptは実行前に型情報を消しJavaScriptへ変換されてから実行される。静的型言語のメリットの一つである実行速度の速さは享受できないが、そもそもJavaScriptはJIT(Just in time)コンパイルによって~~ホントに意味わからないぐらい~~極限まで最適化されて実行されるので、特殊な分野以外では速度の遅さはほとんど気にならない。JavaScriptの高速性に甘えた結果、開発時には型情報が決定しているのに、実行時は型が不確定というどう考えても非効率なシステムになってしまっているということを言っている。

この「非効率」というのはv8エンジンのような極端に高性能なJavaScriptエンジンのおかげで消えているように思いますが、ブラウザの開発が極限まで難しくなるのでブラウザ開発が大企業独占となってしまうという側面があります。ブラウザというのはたくさんあるように思うかもしれませんが、現在現役のJavaScriptエンジンは大抵v8エンジン(Chromeの中身)かJavaScriptCore(Safariの中身)かSpiderMonkey(FireFoxの中身)のみで、それぞれGoogle・Apple・Mozillaという大企業によるものです。

ちなみにMicrosoftは昔はJavaScriptエンジンを作っていたんですが、上記の会社に競争で負けて最新のWebに追随することを諦めています。現在のEdgeの中ではv8エンジンが動いています。あの大企業のMicrosoftが諦めた開発ですからJavaScriptエンジンの開発のレベルの高さはよくわかると思います。

そしてそれらとは対照的にwasmランタイムは、静的型付けですし、アセンブリレベルなのでランタイム側で実装しないといけない部分(JITコンパイラなど)は少ないわけではありませんが、JavaScriptよりはマシです。実際企業の垣根を超えたプログラマのコミュニティやベンチャー企業などでも開発されています。

>開発の敷居が低いのは、簡単だからという理由の他にもエッジデバイス用のランタイムなどブラウザよりもニッチな分野がたくさんあるからという理由もあります。現在はwasmランタイムは一般ユーザー向けのアプリケーションというよりかは、様々なアプリケーションの基盤として使われている傾向があります。

しかしJavaScriptを急に世の中から消すことは不可能に近いので、JavaScriptがなくてもwasmでアプリが作れるという状態に持っていき段階的にjavaScriptを排除していくというアプローチが現実的です。

このアプローチはすでに大企業により進行しています。javaScriptなしでwasmを初期化し実行できたり画面を操るDOM APIをwasmから触れるようにしたりscriptタグでwasmを読み込みJavaScriptからESmoduleとして扱えるようにするなどの仕様が現在も慎重に検討されています。


<!--stackedit_data:
eyJoaXN0b3J5IjpbLTIxMTU4NDc0NzYsODcxNjAzMjE4XX0=
-->