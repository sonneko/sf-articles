# 仮想通貨と電子決済の仕組み

僕は根来と言います。趣味でプログラミングをしていて、Webサイトやプログラミング言語を作っています。

まずは仮想通貨の仕組みについて説明していきます。仮想通貨に管理にはブロックチェーンという技術が使われています。そのブロックチェーンについて説明してきます。
そもそも、仮想通貨を実現するにはどうすればいいかというと、
「人がその通貨をやり取りしたことを正確に記録する信頼できる台帳」を作ればいいです。そうしたらそれぞれの人の持っている通貨の量を一意的かつ信頼を持って言うことができます。
しかし台帳を誰か特定の人(例えばサービス管理運営者が持っていると)、その運営者を信頼しないといけなくなって仮想通貨システムとして成立しないです。よってサービスを利用しているユーザー全員が共同で台帳を管理していちいち同期するようにすればいいというわけです。

ここで前提知識としてハッシュ関数を説明します。ハッシュ関数とは、様々なデータを入力値として与えると、0と1の数の並びが出力される関数です。
性質にはこんなものがあります。
1、入力値を少しでも変えると全く違うものが返ってくる。
2、ある01の並びを出力するような入力を答える時に、「いろんな入力をしてみてその並びと等しいものを探す」という方法より効率的な方法をまだ人類が知らない。
イメージは素因数分解です。
例えば、37*31=1147だったら暗算はできなくても筆算を書いたらすぐすることができます。しかし、1147の素因数は？という問いに答えるのは結構大変です。具体的には割る2・割る3・割る5というように小さい素数から割り切れるかを確認していく必要があります。sqrt(1147)までの素数で全て割り算したら絶対に1147がどのように素因数分解されるかを言うことができます。よって入力される大きな素数っぽい数のスケールの二乗根に比例した回数の割り算をしないといけなくなります。しかし逆向きは1回の計算で済みます。
ちなみに素因数分解と今回システムに使っているハッシュ関数(SHA256と言う)は全く関係ないですが、素因数分解を利用した暗号化技術にRSA暗号があり、Webサイトなどにアクセスする時にも実際に使われています。ちなみに量子コンピュータが話題になっているのは、「ある01の並びを出力するような入力を答える」問題を効率的に解ける(あくまでも)可能性があるからです。

今度は公開鍵暗号について説明します。一般的に思いつく暗号化の方法は、秘密鍵暗号と呼ばれるもので次のように行われます。秘密鍵暗号では「平文→暗号」と「暗号→平文」は同じ鍵を使って行います。秘密鍵が漏れると解読されてしまいますから、どうにか最初に秘密鍵を何らかの安全な環境でお

まずは前提知識としてデジタル署名について解説します。デジタル署名とは「誰かが承認していることを証明するもの」です。デジタル署名はハッシュ関数を使って実現できます。Aさんが承認しているということをBさんが確認するということを考えると、次のようなアルゴリズムでデジタル署名が行われます。
> ※一部説明の都合上簡略化しています。

1、


話を戻しましょう。ブロックチェーンとは一言で言うなら「台帳を全員で安全に管理する仕組み」です。台帳とはここでは仮想通貨の所有者の取引の記録です。具体的には以下のようなものです。
```
AさんがBさんに100p渡した
DさんがCさんに280p渡した
```

このような台帳があれば誰が何p持っているのかわかります。しかしこの台帳が正しい(改竄されていない)ことを証明しないと使い物になりません。なのでその台帳が正しいことをみんなで保証しようという仕組みが必要です。

ひとまずなぜこのようなルールなのかわかなくてもいいので、全体像を把握しましょう。

台帳をひとまとまりに分けてブロックという単位で管理することにします。ブロックの中には、以下の図のように複数の通貨のやり取りの記録それに対応するデジタル署名と、一個前のブロックを入力とした時のハッシュ関数の出力(ハッシュ)と、ハッシュがたまたま00000から始まるハッシュ関数の入力(ナンス値)が入ることにします。
実はこのブロックの列(ブロックチェーン)は枝分かれすることもありますが、クライアント(仮想通貨を使う人)は最も長いブロックチェーンを信用します。

```mermaid
classDiagram
	ブロック1-->ブロック2
	ブロック2-->ブロック3
	class ブロック1{
		+ブロック0を入力としたハッシュ関数の出力()
		AさんがBさんに100p渡した・Aさんの署名
		DさんがCさんに280p渡した・Dさんの署名
		Fさんが500p貰った
		+ナンス値()
	}
	class ブロック2{
		+ブロック1を入力としたハッシュ関数の出力()
		BさんがAさんに1000p渡した・Bさんの署名
		DさんがEさんに370p渡した・Dさんの署名
		CさんがAさんに10p渡した・Cさんの署名
		Gさんが500p貰った
		+ナンス値()
	}
	class ブロック3{
		+ブロック2を入力としたハッシュ関数の出力()
		FさんがXさんに570p渡した・Fさんの署名
		Hさんが500p貰った
		+ナンス値()
	}

```


さて、この構造にしたらなぜこの台帳が改竄されていないことがわかるのかを説明していきます。
まずはブロックの`k`番目について考えていきます。

`k`番目のブロックには、`k-1`番目のブロックのハッシュ値及び取引情報(コンテンツ)が最初に入っています。コンテンツの長さが一定の数値を超えるとナンス値が生成されます。コンピュータ資源を活用して頑張ってたまたま00000から始まるハッシュ値の入力側を探します。この操作はマイニングと呼ばれます。マイニングをしているマイナーは世界にたくさんいて、早い者勝ちで自分の作ったナンス値をブロックの中に入れることができます。ナンス値が見つかったら今度は`k`番目のブロックのハッシュ値が取られて取引情報がどんどん書き込まれていきます。その後は同じ手順です。この時マイナーのなかで最初にナンス値を見つけられた人は一定の仮想通貨上での金額を受け取ることができます。なのでみんなマイニングをしようとするわけですね。これは仕組み上必須なことと捉えることもできますが、仮想通貨の発行源と見ることもできます。ちなみにこの時、具体的な情報を何も提供していないのにマイニングをしたことが証明されているのでこれは不思議だということで「プルーフオブワーク」と言われています。

今度は攻撃者(Xさん)つまり台帳を改竄することで一攫千金を狙っている人目線から見てみましょう。台帳を改竄するには、正しいブロックチェーンとは別の、自分が有利なコンテンツを書き込んだブロックチェーンを作る必要があります。新しく誰かのデジタル署名を作ることはさっき説明した通り不可能なので、すでに既出の取引の金額のところを変えてしまうわけです。

```mermaid
classDiagram
	ブロック1-->ブロック2
	ブロック2-->ブロック3のA
	ブロック2-->ブロック3のB
	class ブロック1{
		+ブロック0を入力としたハッシュ関数の出力()
		AさんがBさんに100p渡した・Aさんの署名
		DさんがCさんに280p渡した・Dさんの署名
		Fさんが500p貰った
		+ナンス値()
	}
	class ブロック2{
		+ブロック1を入力としたハッシュ関数の出力()
		BさんがAさんに1000p渡した・Bさんの署名
		DさんがEさんに370p渡した・Dさんの署名
		CさんがAさんに10p渡した・Cさんの署名
		Gさんが500p貰った
		+ナンス値()
	}
	class ブロック3のA{
		+ブロック2を入力としたハッシュ関数の出力()
		FさんがXさんに570p渡した・Fさんの署名
		Hさんが500p貰った
		+ナンス値()
	}
	class ブロック3のB{
		+ブロック2を入力としたハッシュ関数の出力()
		FさんがXさんに5700000p渡した・Fさんの署名
		Hさんが500p貰った
		+ナンス値()
	}
```




<!--stackedit_data:
eyJoaXN0b3J5IjpbMjAzOTQwNTI0LC0xNzcyMjE4NzM0XX0=
-->