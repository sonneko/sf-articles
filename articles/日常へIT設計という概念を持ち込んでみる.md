# 日常へIT設計という概念を持ち込んでみる

## はじめに
日常生活でのIT設計を考えてみました。

**※これは実際に当てはめてみたらという視点で設計について説明している文章であり、それが現実世界でも有用であるかどうかは保証しません。**

突然ですが、みなさんは「プログラマ」と聞くと何をイメージしますか？「パソコンの黒い画面を開き高速でキーボードを叩いている」という姿を想像する方が多いのではないかと思います。しかし実はそんなことありません。実際は「設計」という作業にもかなりウェイトをかけていることが多いです。

>設計に時間をかけるような開発ステップのことを"Water Fall Model"といい古くからある開発手法の一つで「完璧な設計を作る」という精神のものです。逆に最近流行っているのが真逆の"Ajail Model"で、これは「実際の成果物がないと意味ないよね」という精神の開発手法です。どちらがいいというわけではありませんが、Google・Amazonなど世界的IT企業は"Ajail Model"を採用している傾向にあります。これはIT企業が世の中に増え競争相手が増えたことから、「設計が甘くなったとしてもできるだけ早くユーザーにソフトウェアを届ける」という考え方が増えたからではないかと言われています。
>"かなりウェイトをかける"というのは"Water Model"の場合の話であり現代の開発に同じ枠が適用できるかというと怪しいです。ただ"Ajail Model"も設計を軽んじているわけではありません。

実際僕は今回のSFの公式Webサイトを開発した人の1人ですが、設計の重要性を深く実感することになりました。

## 設計とは
設計が大事と主張してきたものの設計とは何かについて説明していなかったですね。IT開発における設計とは、これから行う作業のためにベースライン・方法などをまとめておくことを言います。プログラミングというタスクの具体的な指示書を作るイメージです。具体的に、スーパーマリオシリーズの最高傑作である（と思う）スーパーマリオオデッセイを作っている人の気持ちになってみましょう。

- どんなゲームを作るのか決める	 キャプチャ（敵に乗り移るアクション）がセールスポイント
ゲームの詳細を決める	 どんなワールドがあってどんなストーリがあって敵はこんなのがいてアイテムにはこれがあって...
- どんなふうに実装するか考える     アイテムを管理するためのプログラムはこんな感じ、マリオを動かすプログラムはこんな感じ、これは具体的にはこんなアルゴリズムをしたら効率的だな...
- どうやってプログラムを整理するか考える     アイテムを管理するプログラムはここに置こう、あ、ここに共通のコードがあるからどこからでも使えるようにここに置いておこう...
- プログラムを書く    よし実装しよう。設計をきちんとしたおかげで何をすればいいか頭が整理されているなぁ...

ゲームデザインの仕事も含まれているので実際にはここまでの作業を同じ人がすることはほとんどないかと思いますが、やっていることは同じようなことです。
>きちんと説明しようとすると専門用語が飛び出すので少し嘘をついています。

日常で言うと、「今晩はカレーがいい」よりも
「今晩はカレーを作ってください。付属の材料リストを参照し冷蔵庫の中にないものをリストアップしてください。ネットでスーパーのチラシを閲覧しセール状態であるかどうか確認してください。もし近頃に不足する材料が安くなることが判明しそれの差額が600円以上になるのであれば指示に反抗してカレー以外を作ることも検討してください。その場合その旨を伝えてください。もしカレーを作ることが決定したら夕方の混む時間よりも前にスーパーに行きリストアップしたものを購入してください。ポイントカードを使用すること。購入後帰宅しカレーの調理を始めてください。....」
の方が絶対いいですよね。頭を使わなくていいので楽です。
でも逆に言えばこの「設計」を作ることにかなり時間がかかりそうですね。「もしカレーを作らない時」についてさえ言及しているからです。カレーを作るならば絶対に必要のない思考を設計する時にしてしまいます。なので逆に非効率です。
つまり設計はあくまでもトレードオフで日常を変えてしまうゲームチェンジャーというわけではありません。
「良いコードと悪いコードで学ぶ設計入門」という僕の愛読書の言葉を引用します。
> 設計にbestはありません。常にbetterを目指しましょう。

## 原則
設計の文脈での原則とは、betterな設計を作るための基本的なルールのことです。ここからは少しプログラミングの用語が出てきますが、それぞれ日常の用語に変換することができます。

### SOLID原則
"SOLID"というのは5つの原則の頭文字をつなげたものです。
#### Single Responsibility Principle (単一責任の原則)
「クラスやモジュールはただ一つの責任を持つべきである。」
手順書や部署は一つの責任を持つべきです。カレーの作り方にハンバーグの作り方が書かれていたらそれを使う人は混乱しますし、後でハンバーグの作り方を知りたいときにまさかカレーの作り方の中にあるとは思わないので探すのに苦労します。またハンバーグの作り方がカレーの作り方以外の他の手順書にも分割して書かれていたら、カレーの作り方を変更した際にハンバーグの作り方についても他の手順書と矛盾していないことを確認しなければいけません。

カレーの作り方
「カレーを作るには野菜を切って野菜を炒める必要がありますが、ハンバーグを作るときも玉ねぎを別で炒める必要があります。さて野菜を入れる順番は....」

他の手順書
「シャキシャキ感を残すためにハンバーグは玉ねぎを生の状態でタネと混ぜて焼きます。」

玉ねぎの扱いについて思いっきり矛盾していますが、それに気づくのは別の紙に書かれている内容のため気づきにくいでしょう。
つまり玉ねぎについての扱いを修正するためには他の手順書に書かれているかもしれない玉ねぎの扱いも同時に確認して同時に修正する必要があります。これはこの「カレーの作り方」という手順書を更新する係の人がカレー以外の手順書も読む必要があり、メタ的にも単一責任の原則に反しています。

また、加えて手順書にはその責任を表すわかりやすい名前をつけるべきです。いくらカレーの作り方のみが全て書かれていても名前が「ハンバーグの作り方」だと意味がないです。

#### Open/Closed Principle (開放/閉鎖の原則)
「プログラムの構成要素は、拡張に対しては開かれており、修正に対しては閉じられているべきである」
既存のものを変更せずに簡単に追加することができるべきです。

悪い例：
>「ほしい物リストをチラシの裏に適当に書き手に入れ次第取り消し線を書いています。もう何年も同じチラシを使っているので書く場所がなくなってきました。小さい文字で頑張って書きます。別に上から順に書いているわけでもないのでまだ手に入れていない欲しいものを探すのが大変で変更もめんどくさいですが大丈夫です。そのうち全てを違うチラシにもう一度小さい字で書き直そうと思います。」

→拡張が大変かつ修正を定期的にしなければいけない。

正しい例：
> 「ほしい物リストは付箋で管理しています。専用の場所に欲しいものを書いた付箋を貼っておき手に入れたら付箋を捨てます。」

 →拡張しやすくて修正も必要ない。
>ちなみにこの手法は、設計という視点以外（プログラムの実行速度やメモリを使う量）においてもメリットがあります。設計をより良くするとパフォーマンスが悪化することもありますが
 
#### Liskov Substitution Principle (リスコフの置換原則)
「サブタイプのオブジェクトはスーパータイプのオブジェクトの仕様に従わなくてはならない」

>ある生物の研究者は鳥類がどのように飛ぶかについての研究を行なっていました。今日はあらゆる鳥類の生物の飛行方法をみるためにヘリコプターからいろいろな生物を落としてどのように飛ぶかを観察しました。しかしペンギンだけは飛ばずにそのまま落ちていってしまいました。

このよくわからない例えの場合、サブタイプのオブジェクトとはペンギンのことで、スーパータイプのオブジェクトとは鳥類のことです。リスコフの置換原則によれば、ペンギンは鳥類の仕様（＝飛べる）に従わないといけないのですが、ペンギンは予想外にそうではありませんでした。そのためペンギンは落下死（＝エラーや脆弱性）してしまいました。この文脈においては「ペンギンは鳥類ではない」としたほうが良かったということです。

実際のプログラミングの世界ではこの「鳥類→カッコウ」といった関係が何重にも続いていきます。その場合でも同じように適用できます。例えば、「もの→生物→鳥類→カッコウ」のような感じです。「もの」は「外部からは見えるもの」という風にするべきで「世界に存在するもの」のようにしてはいけません。なぜならそれらに依存する「生物」との接点で矛盾が生じてしまうからです。事後条件・事前条件についても触れるべきかと思いますがさらに抽象度が高まり説明が難しいので割愛します。

ちなみに名前が置換原則となっているのは、他のサブタイプのオブジェクトに入れ替えても成立したらそれはスーパータイプの仕様に従っていると言えるからです。

#### Interface Segregation Principle (インターフェース分離の原則)
「クライアントが利用しないメソッドへの依存を強制してはいけない」

先ほどと同じく「ものの特徴」をどうやって捉えるかについての話です。「ものの特徴」はできるだけ細かく分けて定義するべきです。

>ある人がハサミを「"もの"を切ることができる」というように定義しました。なのでハサミは任意の"もの"を切ることができる必要があります。なぜならさっきのリスコフの置換原則に従うとそのハサミは"もの"を絶対に切れないといけません。ハサミは任意の"もの"を切ることができないといけないため紙用と肉用と糸用の3つが一緒にくっついている状態でした。

このハサミはわざわざ紙を切るためだけに使用者に肉を切る機能も強制的に提供してしまいます。これは効率が悪いです。
インターフェース分離の原則的な改善案としては、「紙を切ることができる」と「肉を切ることができる」と「糸を切ることができる」の3つの"ものの特徴"を用意することです。

しかしこれではわざわざ切るものを追加するたびに「〜を切ることができる」という"ものの特徴"を追加する必要があり解放/閉鎖の原則に反します。そこでジェネリクスというものを使います。「Aを切ることができる」という"ものの特徴"を作っておいてそこに任意の切るものを入力できるようにしておきます。そうすると「糸を切ることができる」と「イトを切ることができる」といったような重複し分散した手順書を作らないで済みます。これは単一責任の原則的にも良いです。

#### Dependency Inversion Principle (依存関係逆転の原則)
「上位のモジュールは下位のモジュールに依存してはいけない。どちらのモジュールも、抽象に依存すべきである。抽象は実装に依存してはいけない。実装が抽象に依存すべきである。」

要は物事を分類・評価する時は便宜や内側（＝名詞）を見て決めるのではなく、他のものと積極的に干渉しあうところ（＝動詞）を目印にするべきだということです。
例えば、ハサミは「鋭利な金属とプラスチックでできているもの」と捉えるのではなく「〜を切るもの」と定義するべきです。なぜならハサミの本質は鋭利な金属とプラスチックという具体的な材質ではなく切るという抽象的な行為だからです。

プログラマ向けのブログ投稿サービスであるQiitaには設計メソッドについて大阪弁で陽気にわかりやすく紹介している方がいらっしゃいます。プログラミングの知識がなくても楽しめるかと思います。その方が抽象依存について解説している記事を紹介します。

> 後輩「具体じゃなくて抽象に依存してもらえませんか？」〜命名編〜
> https://qiita.com/Yametaro/items/caf16bd79402b1c820e6

> 9歳娘「パパ、具体じゃなくインターフェースに依存して？」
> https://qiita.com/Yametaro/items/a21ff79fdb5a1f49ec9f

### DRY原則 - Don't Repeat Yourself
同じことは繰り返してはいけないということです。何かを変更した時に古いバージョンのコピーがどこかに残っていたらそれを参照してしまいバージョンが混在してしまいます。
これはわかりやすいかと思います。

### KISS原則 - Keep It Simple, Stupid (シンプルに保て、この愚か者め)
「これまで説明してきたように設計を凝って作るのも楽しいですが、そんなことをするぐらいなら早くプログラムを書けそっちの方が人間が理解しやすくて効率がいい。」ということです。要はシンプルイズベストです。

### YAGNI - You Aren't Gonna Need It (どうせ必要ないだろう)
こんなことを未来に追加するだろうといってそれを何も決まっていない今に作るのは無駄だということです。大抵の未来予言は外れるという経験論から来ています。

### SoC - Separation of Concerns (関心の分離)
ものをモデル化するときに、「物品」なら発送先と金額と内容量と在庫などの情報を含む必要があります。しかしそれをごちゃ混ぜにしてはいけないということです。単に物品といっても、配送業者・お客さん・製造会社などさまざまな視点から見たときに必要な情報（=関心）が集合しているので、「配送品」・「商品」・「生産物」のように分けて管理する方が良いです。

もし「物品を管理する」と言う曖昧なタスクを直接作ってしまうと、お客さんに生産ラインの状態という知らなくてもいい情報を渡してしまい非効率かつセキュリティに問題が生じます。

## ナントカ駆動開発
人は複雑なことを考えるのが大抵好きではないし間違いをしそうだと予想をします。そして大抵その予想は当たります。なので何かに任せて複雑なこと（＝開発）をしようという考え方があります。それがナントカ駆動開発です。それぞれ名前が非常にかっこいいと思うので一つぐらい覚えて必要に応じてイキって頂けたらと思います。ほんとはもっとたくさんありますがここでは紹介しません。
知りたい人は、
https://qiita.com/muson0110/items/c15d6a0ba0582da204e1
https://qiita.com/ShortArrow/items/0fbe856cb342aa55b756
をご覧ください。

#### テスト駆動開発(Test-Driven-Development)・振る舞い駆動開発(Behavior-Driven-Development)
テストをまず書き、その後そのテストを通すための最小限のプログラムを書くというプロセスを何度も繰り返すというアプローチです。
テストというのは対象のプログラムがきちんと動いているかを確認するためのプログラムのことなんですが、それは具体的なメソッドであって「今から書くプログラムはどんな動きをするのか」を明示的に定義するということが本質です。
何かをするときに、その何かをできるだけ細かく分解してそれぞれについてまずはその何かというのは「何が目的」そして「その目的に合致するのはこの範囲だ」というのを決めそれを明文化することが大切だということです。

#### 仕様駆動開発(Specification-Driven-Development)・AI駆動開発(AI-Driven-Development)
最近のchatGPTやGeminiやclaudeなどに代表されるLLMに依存した最先端な開発方法です。
先ほどはテストによって本体のプログラムを管理していましたが、このナントカ駆動開発では自然言語(＝日本語など)によって管理します。そしてこの自然言語によるソフトウェアの説明をもとにAIがプログラムを書きます。人間はプログラム本体を触らず自然言語のみを管理します。
別の記事でも触れていますが、僕的にはAIはツールであって動作主体になってはいけないと思っていますから、このナントカ駆動開発には反対です。
> ちなみにこの自然言語によるソフトウェアの説明はかなり具体的に記入しないとAIはいいコードを書いてくれません。単純に「こんなゲーム」と指示するのではなく「こんなふうなアルゴリズムを用いてこのデータはここで管理して」という詳細で専門的な内容になります。AIはそんなに賢くありません。プログラムが書けなくてもゲームを作れるのかと期待した人はごめんなさい。結局はプログラミングと同等の能力を求められます。

#### ドメイン駆動開発(Domain-Driven-Development)
SoC原則(関心の分離)を厳守してドメインについて分離して開発を行うというスタイルのことです。僕が作るような比較的小規模なプログラムだと技術駆動で開発を進めた方が効率的なのですが、大規模になるとこちらの方が断然効率的になると言われています。大規模なソフトウェアのプログラムを見ていると分かるのですが、ほとんどがドメイン分割を行なっているという印象があります。

#### モデル駆動開発(Model-Driven-Development)
手続き的にではなく宣言的にプログラムを書きましょうというものです。
```手続き的の例
カレーには玉ねぎが含まれています。
カレーは鍋で作ります。
カレーにはレモンを入れないです。
カレーにはじゃがいもが含まれています。
カレーはスプーンで食べます。
ハンバーグには玉ねぎが含まれています。
ハンバーグはフォークで食べます。
ハンバーグには挽肉が含まれています。
ハンバーグはフラインパンで作ります。
```

```宣言的の例
含まれているもの：
	カレー：玉ねぎ・じゃがいも・×レモン
	ハンバーグ：玉ねぎ・挽肉
作る道具：
	カレー：鍋
	ハンバーグ：フライパン
使う食器：
	カレー：スプーン
	ハンバーグ：フォーク
```

## 命名規則



# 参考文献・謝辞
「良いコードと悪いコードで学ぶ設計入門」（仙傷大也さん）
https://www.sbcurry.com/recipe/standard01/：「基本のカレーの作り方」
https://www.sirogohan.com/recipe/hanba-gu/：「家庭的な基本のハンバーグのレシピ/作り方」

Claude・Gemini：一部のどうしても思いつかなかった例えを提案してくれました。

<!--stackedit_data:
eyJoaXN0b3J5IjpbMTk1ODg1NjA3LC0xOTMzODQ5MDNdfQ==
-->